# Quest 14. Hello, MySQL


## Introduction
* 이번 퀘스트에서는 DB가 무엇인지, 어떻게 사용하는 것인지 등을 알아보겠습니다.

## Topics
* RDBMS (관계형 데이터베이스 관리 시스템(Relational database management system))
  * MySQL
* 각종 쿼리
  * `CREATE`, `SELECT`, `UPDATE`, `DELETE`
* Hash - 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 알고리즘이다. 해시 함수에 의해 얻어지는 값은 해시 값, 해시 코드, 체크섬 또는 해시, 암호화가 아닌 단방향 해시 알고리즘. '비둘기 집의 원리'
  * SHA256 - SHA256은 64자리의 16진수 문자열이 출력

## Resources
* [Head First PHP & MySQL](http://www.yes24.com/24/Goods/3831680?Acode=101), 한빛미디어
* [Real MySQL : 개발자와 DBA를 위한](http://www.yes24.com/24/Goods/6960931?Acode=101), 위키북스

## Checklist
* RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?
    * data type???
* RDBMS 테이블의 정규화는 무엇인가요?
    * 함수적 종속성: 릴레이션R에서 에트리뷰트 A가 B의 결정자이면, B가 A에 함수적으로 종속한다고 말한다.
        * 결정자:  사원의id를 알면 사원의 이름, 팀을 알 수 있다. 그에 반해 팀은 여러명의 사원, id들을 나타낼 수 있기 때문에 결정자라고 할 수 없다.
        * 완전함수종속: 한 속성이 오직 기본키에만 종속
        * 부분함수종속: 한 속성이 기본키가 아닌 다른 속성에 종속 되거나 기본키가 2개이상의 합성키일경우 이중 일부 속성에 종속
        * 이행적함수종속: 세가지 종속간의 종속이 (A → B) & (B → C) 일경우 A → C가 성립되는 종속
    * 테이블의 속성들의 종속적인 관계를 이용해 테이블을 무손실 분해하는 과정으로 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.
    * 제 1정규형(1NF; First Normal Form) : 테이블에 속한 모든 속성의 도메인이 원자 값
    * 제 2정규형(2NF) : 기본키가 아닌 모든 속성이, 기본키에 대하여 완전 함수적 종속을 만족 (1NF에서 부분적 함수 종속 제거)
    * 제 3정규형(3NF) : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음 (2NF에서 이행적 함수적 종속 제거)
    * BCNF: 모든 결정자가 후보키
* MySQL 엔진에는 어떤 것들이 있나요?
    * MyISAM, InnoDB, Archive, Memory, NDB 등등
* RDBMS에서 테이블의 인덱싱은 무엇인가요?
    * RDBMS에서 검색속도를 높이기 위해 테이블의 컬럼들을 따로 저장한 data structure - TABLE의 컬럼을 따로 저장하여 검색시 해당 TABLE을 full scan 하는게 아니라 INDEX 파일을 검색하여 검색속도를 빠르게 한다.
* 인덱싱을 하면 어떤 점이 다른점
    * 만약 INDEX를 사용하지 않은 SEELCT쿼리라면 해당 TABLE full scan하여 모두 검색합니다.
    * 인덱스가 추가된 테이블의 검색속도가 인덱스가 추가되지 않은 테이블보다 빠르다. 데이터양이 많아질수록 더욱 차이난다.
* 어떤 식으로 동작하나요?
    * INDEX는 해당 컬럼을 B-트리를 사용하여 따로 저장한다. 또한, 인덱스는 실제 테이블의 각열의 주소를 갖는 포인터를 저장한다. INDEX가 사용할경우 실제 TABLE을 Full scan하는것이 아니라 인덱스를을 검색하여 포인터를 통해 실제 테이블에 접근한다.
* DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
    * HASH알고리즘을 통해서 사용자의 암호를 DB에 HASH코드로 저장이 되있어, 사용자가 암호를 입력할때 HASH알고리즘을 통해 값을 비교
## Quest
* 주어진 MySQL 서버에서 Quest 12~13의 결과물을 MySQL 기반으로 만들어 보고자 합니다.
  * 먼저 테이블이 어떻게 설계되어야 할지, 어떤 정보를 담고 있어야 할지 생각해 보세요
  * 사용자의 암호는 어떤 식으로 저장해야 할까요?
    * sha2-256으로 저장하기 위해 insert할때 sha2('test1', 256) 이렇게 한다.
* **주의: 실제 node.js 프로그래밍을 할 필요는 없습니다. 알맞는 테이블만 생성하시면 됩니다!**

## 추가자료
* [MySQL 내부구조](http://mysqldba.tistory.com/2)
* [MySQL storage Engine별 특징](http://mysqldba.tistory.com/9)


## 추가
* 홈페이지에서 비밀번호를 까먹었을때 다시 찾을 수 없는 경우(변경은 가능) HASH알고리즘을 사용했기 때문
* Hash 알고리즘의 경우 원래 정보가 손실되어 복호화가 불가능
* 보통 크기를 알 수 없는 곳에는 text 타입을, 정해진 크기가 있는 곳에는 char 타입을, 최대 크기는 알 수 있지만 가변적이라면 varchar 사용
